// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: users.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUsers = `-- name: CreateUsers :one
INSERT INTO users(
    id,
    full_name,
    email,
    created_at,
    updated_at,
    is_deleted,
    deleted_at,
    dob,
    phone_number,
    profile_pic,
    user_status,
    password,
    role,
    bank_branch,
    is_verified,
    api_key
    
)VALUES(
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,
    encode(sha256(random()::text::bytea),'hex')
)RETURNING id, full_name, email, role, password, bank_branch, dob, created_at, updated_at, is_deleted, deleted_at, phone_number, profile_pic, user_status, is_verified, api_key
`

type CreateUsersParams struct {
	ID          uuid.UUID `json:"id"`
	FullName    string    `json:"full_name"`
	Email       string    `json:"email"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	IsDeleted   bool      `json:"is_deleted"`
	DeletedAt   time.Time `json:"deleted_at"`
	Dob         string    `json:"dob"`
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	UserStatus  bool      `json:"user_status"`
	Password    string    `json:"password"`
	Role        string    `json:"role"`
	BankBranch  string    `json:"bank_branch"`
	IsVerified  bool      `json:"is_verified"`
}

func (q *Queries) CreateUsers(ctx context.Context, arg CreateUsersParams) (User, error) {
	row := q.db.QueryRow(ctx, createUsers,
		arg.ID,
		arg.FullName,
		arg.Email,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsDeleted,
		arg.DeletedAt,
		arg.Dob,
		arg.PhoneNumber,
		arg.ProfilePic,
		arg.UserStatus,
		arg.Password,
		arg.Role,
		arg.BankBranch,
		arg.IsVerified,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Role,
		&i.Password,
		&i.BankBranch,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.PhoneNumber,
		&i.ProfilePic,
		&i.UserStatus,
		&i.IsVerified,
		&i.ApiKey,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users
SET
   is_deleted = True,
   deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const forgetPassword = `-- name: ForgetPassword :exec
UPDATE users
SET
    updated_at = NOW(),
    password = $1,
    api_key = encode(sha256(random()::text::bytea),'hex')
WHERE id = $2
`

type ForgetPasswordParams struct {
	Password string    `json:"password"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) ForgetPassword(ctx context.Context, arg ForgetPasswordParams) error {
	_, err := q.db.Exec(ctx, forgetPassword, arg.Password, arg.ID)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id,full_name, email,created_at,updated_at,phone_number,profile_pic,role,api_key 
FROM users
`

type GetAllUsersRow struct {
	ID          uuid.UUID `json:"id"`
	FullName    string    `json:"full_name"`
	Email       string    `json:"email"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	Role        string    `json:"role"`
	ApiKey      string    `json:"api_key"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhoneNumber,
			&i.ProfilePic,
			&i.Role,
			&i.ApiKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id,full_name, email,created_at,updated_at,phone_number,profile_pic,role,api_key,password,is_verified,bank_branch ,dob
FROM users WHERE email = $1 AND is_deleted=False
`

type GetUserByEmailRow struct {
	ID          uuid.UUID `json:"id"`
	FullName    string    `json:"full_name"`
	Email       string    `json:"email"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	Role        string    `json:"role"`
	ApiKey      string    `json:"api_key"`
	Password    string    `json:"password"`
	IsVerified  bool      `json:"is_verified"`
	BankBranch  string    `json:"bank_branch"`
	Dob         string    `json:"dob"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.ProfilePic,
		&i.Role,
		&i.ApiKey,
		&i.Password,
		&i.IsVerified,
		&i.BankBranch,
		&i.Dob,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id,full_name, email,created_at,updated_at,phone_number,profile_pic,role,api_key ,password,bank_branch,dob
FROM users WHERE id = $1 AND is_deleted=False
`

type GetUserByIdRow struct {
	ID          uuid.UUID `json:"id"`
	FullName    string    `json:"full_name"`
	Email       string    `json:"email"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	Role        string    `json:"role"`
	ApiKey      string    `json:"api_key"`
	Password    string    `json:"password"`
	BankBranch  string    `json:"bank_branch"`
	Dob         string    `json:"dob"`
}

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.ProfilePic,
		&i.Role,
		&i.ApiKey,
		&i.Password,
		&i.BankBranch,
		&i.Dob,
	)
	return i, err
}

const getUserByPhoneNumber = `-- name: GetUserByPhoneNumber :one
SELECT id,full_name, email,created_at,updated_at,phone_number,profile_pic,role,api_key,password ,bank_branch,dob
FROM users WHERE phone_number = $1 AND is_deleted=False
`

type GetUserByPhoneNumberRow struct {
	ID          uuid.UUID `json:"id"`
	FullName    string    `json:"full_name"`
	Email       string    `json:"email"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	Role        string    `json:"role"`
	ApiKey      string    `json:"api_key"`
	Password    string    `json:"password"`
	BankBranch  string    `json:"bank_branch"`
	Dob         string    `json:"dob"`
}

func (q *Queries) GetUserByPhoneNumber(ctx context.Context, phoneNumber string) (GetUserByPhoneNumberRow, error) {
	row := q.db.QueryRow(ctx, getUserByPhoneNumber, phoneNumber)
	var i GetUserByPhoneNumberRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhoneNumber,
		&i.ProfilePic,
		&i.Role,
		&i.ApiKey,
		&i.Password,
		&i.BankBranch,
		&i.Dob,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
    updated_at = NOW(),
    phone_number = $1,
    profile_pic = $2,
    user_status = $3,
    password = $4,
    api_key = encode(sha256(random()::text::bytea),'hex')
WHERE id = $5
`

type UpdateUserParams struct {
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	UserStatus  bool      `json:"user_status"`
	Password    string    `json:"password"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.PhoneNumber,
		arg.ProfilePic,
		arg.UserStatus,
		arg.Password,
		arg.ID,
	)
	return err
}

const updateUserPhoneNumber = `-- name: UpdateUserPhoneNumber :exec
UPDATE users
SET
    updated_at = NOW(),
    phone_number = $1,
    api_key = encode(sha256(random()::text::bytea),'hex')
WHERE id = $2
`

type UpdateUserPhoneNumberParams struct {
	PhoneNumber string    `json:"phone_number"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPhoneNumber(ctx context.Context, arg UpdateUserPhoneNumberParams) error {
	_, err := q.db.Exec(ctx, updateUserPhoneNumber, arg.PhoneNumber, arg.ID)
	return err
}

const updateUserbyAdmin = `-- name: UpdateUserbyAdmin :exec
UPDATE users
SET
    updated_at = NOW(),
    phone_number = $1,
    profile_pic = $2,
    user_status = $3,
    password = $4,
    role = $5,
    api_key = encode(sha256(random()::text::bytea),'hex')
WHERE id = $6
`

type UpdateUserbyAdminParams struct {
	PhoneNumber string    `json:"phone_number"`
	ProfilePic  string    `json:"profile_pic"`
	UserStatus  bool      `json:"user_status"`
	Password    string    `json:"password"`
	Role        string    `json:"role"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserbyAdmin(ctx context.Context, arg UpdateUserbyAdminParams) error {
	_, err := q.db.Exec(ctx, updateUserbyAdmin,
		arg.PhoneNumber,
		arg.ProfilePic,
		arg.UserStatus,
		arg.Password,
		arg.Role,
		arg.ID,
	)
	return err
}

const userStatusUpdate = `-- name: UserStatusUpdate :exec
UPDATE users
SET
    updated_at = NOW(),
    is_verified = $1,
    api_key = encode(sha256(random()::text::bytea),'hex')
WHERE id = $2
`

type UserStatusUpdateParams struct {
	IsVerified bool      `json:"is_verified"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UserStatusUpdate(ctx context.Context, arg UserStatusUpdateParams) error {
	_, err := q.db.Exec(ctx, userStatusUpdate, arg.IsVerified, arg.ID)
	return err
}
